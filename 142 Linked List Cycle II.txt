Intuition
2 Approach to this solution.
Using Set
Using Floyd - cycle Detection (Fast and slow pointers)

Approach 1 : Using Set
Step 1 : We store the nodes in the set.
Step 2 : During each iteration we check if the node exists in the set, if yes just return the node.
Otherwise we add the node in the set.
Step 3 : If the list does not contain the loop, the loop will be terminated by not null condition so just return null at the end.

Complexity
Time complexity:
O(n) to traverse the list.
Space complexity:
O(n) extra space required to store nodes in Set.

Code
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) 
    {
        if(head==null || head.next==null)
        {
            return null;
        }    

        // /* 
        //     Used Set because it will store unique references of nodes in it.
        //     Once a node is stored, it will be treated as unique node in set.
        //     If again that node comes Set will not take that element and we can find the starting of that cycle
        // */

        Set<ListNode> set = new HashSet<>();
        ListNode T = head;
        while(T!=null)
        {
            if(set.contains(T))
            {
                return T;
            }

            set.add(T);
            T = T.next;
        }

        //If whole loop is executed and next is null, that means there is no cycle in the list.
        return null;     
    }
}


Approach 2 : Usinf Floyd-Cycle detection (Fast and slow pointer)
Step 1 : Assign both fast and slow pointer to the head linkedlist
Step 2 : Run the till fast becomes null or fast's next is null
iterate fast by 2 nodes
iterate slow by 1 node
Step 3 : If there is a cycle then these two pointers will be stuck in the cycle and there will be a time where both the pointers will point to the same. If they both point to same node then we say true to loopExists.
Otherwise we say false to loopExists and return null.
Step 4 : If the loop exists then, we assign the slow pointer to head and run a till slow pointer meets the fast. (Here, both fast and slow move one step at a time).
If the slow and fast meet again then thats the starting of the loop. So we just return fast or slow node.

Complexity
Time complexity:
O(n) to traverse the list.
Space complexity:
O(n) extra space required to store nodes in Set.

Code
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) 
    {
        if(head==null || head.next==null)
        {
            return null;
        }

        ListNode T=head,S=head;
        boolean loopExists = false;
        while(T!=null && T.next!=null)
        {
            T = T.next.next;
            S = S.next;

            if(T==S)
            {
                loopExists = true;
                break;
            }
        }

        if(loopExists)
        {
            S = head;
            while(S != T)
            {
                S = S.next;
                T = T.next;
            }

            return T;
        }

        return null;   
    }
}
