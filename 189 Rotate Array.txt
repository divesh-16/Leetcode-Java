Intuition
I used the 3rd Hint to solve this problem. It almost solved the whole question without even solving.

Hint : One line of thought is based on reversing the array (or parts of it) to obtain the desired result. Think about how reversal might potentially help us out by using an example.

But first we need to understand the 'parts', which is determined by given value K. It basically tells the numbers to rotate, simply put "till when to reverse in an array".

So, the 1st part of an array becomes 0 to k-1 and 2nd part becomes k to n-1.

But what if K is bigger than length of an array ?
Ans : We simply mod K with length so to get minimum steps to rotate(K = K % nums.length). If length is bigger than K then K remains same but if K is bigger than length we exclude extra rotation and rotate only required steps. (e.g : K = 10 and n = 3, array rotates 9 times and comes back to original position which makes no sense of rotation. Now only 1 rotation remains out of 10 to give answer. Therefore we K = K % N which gives 1 = 10 % 3. And now we rotate array only 1 time)

Approach
First reduce K = K % N (nums.length)

The question can be solved in three 3 basic steps :
1) Reverse the whole array.
2) Reverse the array from 0 to K-1 position.
3) Reverse the array from k to n.

Complexity
Time complexity:
1st Reverse takes O(n)
2nd Reverse takes O(n)
3rd Reverse takes O(n)
Therefore 3*O(n) ~ O(n) 
Space complexity:
O(1)


Code 


class Solution 
{
    public void reverse(int a[],int lb, int ub)
    {
        while(lb<ub)
        {
            int t = a[lb];
            a[lb] = a[ub];
            a[ub] = t;

            lb++;
            ub--;

        }
    }

    public void rotate(int[] nums, int k) 
    {
        // if(nums.length == 1 || k ==0)
        // {
        //     return;
        // }

        k = k % nums.length;

        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);    
    }
}
