Intuition
We can solve this question using two approaches
First, using stack.
Second, reverse the 1st half of list and check with 2nd half

Approach 1 : Using Stack.
Step 1 : Create a stack and put all the nodes of list in the stack.
Step 2 : Now start at first node and top element of stack till node becomes null and stack is empty.
Step 3 : In each iteration check whether the pop element is equal to current node's data
If yes, continue
If no, return false(i.e list is not a palindrome)
Step 4 : Once all nodes are popped from stack it means list is palindrome, simply return true.

Complexity
Time complexity:
O(n) to traverse list to store elements in stack.
O(n) to travsers list again to check palindrome.
O(2n) ~ O(n)
Space complexity:
O(n) extra space for stack.

Code
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) 
    {
        Stack<Integer> stk = new Stack<>();

        ListNode T = head;
        for(; T!=null; T=T.next)
        {
            stk.push(T.val);
        }
        T = head;
        for(; T!=null; T=T.next)
        {
            if(stk.pop()==T.val)
            {
                continue;
            }

            return false;
        }

        return true;
    }
}



Approach 1 : Using Reverse Strategy. Optimal solution
Step 1. Get middle of linked list
Step 2. Reverse the second half.
Step 3. compare first half with second half
Step 4. construct the origial by reversing the second half. (Not necessary here)

Complexity
Time complexity:
O(n) for finding the middle and reversing
O(n) for check palindrome
O(2n) ~ O(n)
Space complexity:
O(1) constant space.


Code
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution 
{
    public ListNode reverse(ListNode head)
    {
        ListNode t=head,s=null,r=null;

        while(t!=null)
        {
            s=t;
            t=t.next;
            s.next = r;
            r=s;
        }

        return r;
    }

    public boolean isPalindrome(ListNode head) 
    {
        ListNode f = head,s=head,m = null;

        while(f != null && f.next != null)
        {
            f = f.next.next;
            m = s;
            s = s.next;

        }
        
        ListNode head2 = null;
        if(f == null) // even nodes.
        {
            m.next = null;
            head2 = reverse(s);

            ListNode T = head, L = head2;

            while(T != null && L != null)
            {
                if(T.val != L.val)
                {
                    return false;
                }
                T = T.next;
                L = L.next;
            }

            return true;

        }
        else
        {
            head2 = reverse(s.next);

            ListNode T = head, L = head2;

            while(T != s && L != null)
            {
                if(T.val != L.val)
                {
                    return false;
                }
                T = T.next;
                L = L.next;
            }

            return true;

        }
    }
}
